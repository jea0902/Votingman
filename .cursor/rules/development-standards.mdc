---
description: 시니어 풀스택 개발자 및 시스템 아키텍트 코딩 표준
alwaysApply: true
---

# 개발 표준 및 아키텍처 가이드라인

## 1. 설계 우선 원칙

코드를 작성하기 전에 반드시 설계 의도를 먼저 설명해야 합니다.

### 설계 설명에 포함할 내용:
- **목적**: 이 코드가 해결하려는 문제는 무엇인가?
- **아키텍처 결정**: 왜 이 방식으로 구현하는가?
- **의존성**: 다른 모듈/컴포넌트와의 관계는?
- **확장성**: 향후 변경사항을 어떻게 수용할 것인가?

### 예시:
```typescript
/**
 * 설계 의도:
 * - 사용자 인증을 위한 JWT 기반 토큰 관리 모듈
 * - 토큰 갱신, 만료 처리, 보안 검증을 중앙화
 * - 향후 OAuth, 2FA 확장 가능하도록 인터페이스 기반 설계
 */
```

---

## 2. 권한 및 소유권 검증 (Authorization) ⚠️ 필수

**모든 리소스 수정/삭제 API는 반드시 소유권 검증을 포함해야 합니다.**

### 핵심 원칙:
- **절대 신뢰 금지**: 클라이언트에서 보낸 user_id를 절대 신뢰하지 않음
- **서버 세션 기반**: 항상 서버 세션에서 현재 사용자 ID 추출
- **리소스 소유권 확인**: 수정/삭제 전 해당 리소스의 소유자인지 검증
- **RLS 활용**: Supabase RLS 정책으로 데이터베이스 레벨 보호

### 예시:
```typescript
// ❌ BAD: 클라이언트 데이터 신뢰 (보안 취약)
export async function DELETE(request: Request) {
  const { postId, userId } = await request.json();
  await supabase.from('posts').delete().eq('id', postId).eq('user_id', userId);
}

// ✅ GOOD: 서버 세션에서 사용자 확인 + 소유권 검증
export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  // 1. 서버에서 현재 사용자 세션 확인
  const supabase = await createClient();
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    return NextResponse.json(
      { success: false, error: { code: 'UNAUTHORIZED', message: '로그인이 필요합니다' } },
      { status: 401 }
    );
  }
  
  // 2. 리소스 소유권 확인
  const { data: post } = await supabase
    .from('posts')
    .select('user_id')
    .eq('id', params.id)
    .single();
  
  if (!post) {
    return NextResponse.json(
      { success: false, error: { code: 'NOT_FOUND', message: '게시글을 찾을 수 없습니다' } },
      { status: 404 }
    );
  }
  
  if (post.user_id !== user.id) {
    return NextResponse.json(
      { success: false, error: { code: 'FORBIDDEN', message: '삭제 권한이 없습니다' } },
      { status: 403 }
    );
  }
  
  // 3. 소유권 확인 후 삭제 실행
  const { error } = await supabase.from('posts').delete().eq('id', params.id);
  
  if (error) {
    return NextResponse.json(
      { success: false, error: { code: 'DELETE_FAILED', message: '삭제에 실패했습니다' } },
      { status: 500 }
    );
  }
  
  return NextResponse.json({ success: true, data: { deleted: true } });
}
```

### 권한 검증 체크리스트:
- [ ] 모든 POST/PUT/PATCH/DELETE API에 인증 확인
- [ ] 리소스 수정/삭제 시 소유권 검증
- [ ] 관리자 기능은 role 기반 권한 검사
- [ ] Supabase RLS 정책 설정 확인

---

## 3. API 응답 표준화

**모든 API는 일관된 응답 형식을 사용해야 합니다.**

### 표준 응답 형식:
```typescript
// 성공 응답
interface SuccessResponse<T> {
  success: true;
  data: T;
  meta?: {
    page?: number;
    limit?: number;
    total?: number;
  };
}

// 실패 응답
interface ErrorResponse {
  success: false;
  error: {
    code: string;      // 'UNAUTHORIZED' | 'FORBIDDEN' | 'NOT_FOUND' | 'VALIDATION_ERROR' | 'SERVER_ERROR'
    message: string;   // 사용자에게 표시할 메시지
    details?: unknown; // 개발용 상세 정보 (프로덕션에서는 제외)
  };
}
```

### HTTP 상태 코드 규칙:
| 상태 코드 | 사용 상황 |
|----------|----------|
| 200 | 성공 (조회, 수정) |
| 201 | 생성 성공 |
| 400 | 잘못된 요청 (유효성 검증 실패) |
| 401 | 인증 필요 (로그인 안됨) |
| 403 | 권한 없음 (로그인됐지만 권한 없음) |
| 404 | 리소스 없음 |
| 500 | 서버 에러 |

### 예시:
```typescript
// ✅ 표준화된 API 응답
export async function GET(request: Request) {
  try {
    const { data, error } = await supabase.from('posts').select('*');
    
    if (error) throw error;
    
    return NextResponse.json({
      success: true,
      data: data,
      meta: { total: data.length }
    });
    
  } catch (error) {
    console.error('Posts fetch error:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'SERVER_ERROR',
          message: '게시글을 불러오는데 실패했습니다'
        }
      },
      { status: 500 }
    );
  }
}
```

---

## 4. 데이터베이스 및 RLS 규칙

### Supabase RLS (Row Level Security) 필수:
```sql
-- 모든 테이블에 RLS 활성화
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

-- 조회: 모든 사용자 허용
CREATE POLICY "Anyone can view posts" ON posts
  FOR SELECT USING (true);

-- 생성: 인증된 사용자만, 본인 ID로만
CREATE POLICY "Users can create own posts" ON posts
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 수정: 본인 게시글만
CREATE POLICY "Users can update own posts" ON posts
  FOR UPDATE USING (auth.uid() = user_id);

-- 삭제: 본인 게시글만
CREATE POLICY "Users can delete own posts" ON posts
  FOR DELETE USING (auth.uid() = user_id);
```

### 쿼리 최적화 규칙:
- **N+1 쿼리 금지**: 반복문 안에서 쿼리 실행 금지
- **필요한 컬럼만 SELECT**: `select('*')` 대신 필요한 컬럼 명시
- **인덱스 활용**: WHERE 절에 사용되는 컬럼은 인덱스 확인
- **페이지네이션 필수**: 10개 이상 목록은 반드시 페이지네이션

### 예시:
```typescript
// ❌ BAD: N+1 쿼리 문제
const posts = await supabase.from('posts').select('*');
for (const post of posts.data) {
  const author = await supabase.from('users').select('*').eq('id', post.user_id);
  post.author = author.data;
}

// ✅ GOOD: JOIN으로 한 번에 조회
const { data: posts } = await supabase
  .from('posts')
  .select(`
    id,
    title,
    content,
    created_at,
    user:users!user_id (
      id,
      nickname,
      avatar_url
    )
  `)
  .order('created_at', { ascending: false })
  .range(0, 9); // 페이지네이션
```

---

## 5. 성능 최적화 기준

### 성능 목표:
| 항목 | 목표 | 측정 방법 |
|-----|------|----------|
| API 응답 시간 | < 200ms | 서버 로그 |
| 첫 화면 로딩 (LCP) | < 2.5s | Lighthouse |
| 인터랙션 응답 (FID) | < 100ms | Lighthouse |

### 프론트엔드 최적화 규칙:
```typescript
// 1. 이미지 최적화 - next/image 필수 사용
import Image from 'next/image';
<Image src={url} alt="" width={300} height={200} loading="lazy" />

// 2. 컴포넌트 지연 로딩 - 모달, 무거운 컴포넌트
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <Skeleton />
});

// 3. 데이터 캐싱 - SWR 또는 React Query 사용
const { data, isLoading, error, mutate } = useSWR('/api/posts', fetcher, {
  revalidateOnFocus: false,
  dedupingInterval: 60000, // 1분간 중복 요청 방지
});

// 4. 메모이제이션 - 비용이 큰 연산
const sortedPosts = useMemo(() => 
  posts.sort((a, b) => b.likes - a.likes), 
  [posts]
);

// 5. 디바운싱 - 검색, 자동저장
const debouncedSearch = useMemo(
  () => debounce((term: string) => search(term), 300),
  []
);
```

### 번들 크기 최적화:
```typescript
// ❌ BAD: 전체 라이브러리 import
import _ from 'lodash';

// ✅ GOOD: 필요한 함수만 import
import debounce from 'lodash/debounce';

// ❌ BAD: 클라이언트에서 불필요한 서버 코드
'use client';
import { createClient } from '@/lib/supabase/server'; // 서버 전용!

// ✅ GOOD: 클라이언트용 import
'use client';
import { createClient } from '@/lib/supabase/client';
```

---

## 6. 프론트엔드 상태 관리 패턴

### UI 상태 필수 처리:
**모든 비동기 UI는 4가지 상태를 반드시 처리해야 합니다.**

```typescript
// ✅ 4가지 상태 모두 처리
function PostList() {
  const { data, isLoading, error } = useSWR('/api/posts', fetcher);
  
  // 1. 로딩 상태
  if (isLoading) {
    return <PostListSkeleton />;
  }
  
  // 2. 에러 상태
  if (error) {
    return (
      <ErrorMessage 
        message="게시글을 불러오는데 실패했습니다"
        onRetry={() => mutate()}
      />
    );
  }
  
  // 3. 빈 상태
  if (!data || data.length === 0) {
    return <EmptyState message="아직 게시글이 없습니다" />;
  }
  
  // 4. 성공 상태
  return (
    <ul>
      {data.map(post => <PostItem key={post.id} post={post} />)}
    </ul>
  );
}
```

### 폼 제출 패턴:
```typescript
// ✅ 중복 제출 방지 + 로딩 상태 + 에러 처리
function CreatePostForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    
    // 중복 제출 방지
    if (isSubmitting) return;
    
    setIsSubmitting(true);
    
    try {
      const response = await fetch('/api/posts', {
        method: 'POST',
        body: JSON.stringify(formData),
      });
      
      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.error.message);
      }
      
      toast.success('게시글이 작성되었습니다');
      router.push(`/posts/${result.data.id}`);
      
    } catch (error) {
      toast.error(error instanceof Error ? error.message : '작성에 실패했습니다');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* 폼 필드들 */}
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '작성 중...' : '작성하기'}
      </Button>
    </form>
  );
}
```

### 낙관적 업데이트 (Optimistic Update):
```typescript
// ✅ 좋아요 등 즉각적인 피드백이 필요한 경우
async function handleLike(postId: string) {
  // 1. UI 즉시 업데이트 (낙관적)
  setIsLiked(true);
  setLikeCount(prev => prev + 1);
  
  try {
    // 2. 서버 요청
    const response = await fetch(`/api/posts/${postId}/like`, {
      method: 'POST',
    });
    
    if (!response.ok) {
      throw new Error('Failed to like');
    }
    
  } catch (error) {
    // 3. 실패 시 롤백
    setIsLiked(false);
    setLikeCount(prev => prev - 1);
    toast.error('좋아요에 실패했습니다');
  }
}
```

---

## 7. 코드 주석 및 문서화

모든 코드 블록에는 목적과 동작을 설명하는 주석이 필요합니다.

### 주석 작성 규칙:
- **함수/클래스**: 목적, 파라미터, 반환값, 예외 설명
- **복잡한 로직**: 알고리즘 설명 및 의도
- **비즈니스 로직**: 도메인 규칙 설명
- **보안 관련**: 보안 고려사항 명시
- **TODO 주석**: 반드시 담당자와 기한 명시 `// TODO(@username): 설명 - YYYY-MM-DD`

---

## 8. 보안 검토 체크리스트

모든 코드는 다음 보안 항목을 검토해야 합니다.

### 필수 체크리스트:
- [ ] **인증 확인**: 보호된 API에 `getUser()` 호출
- [ ] **권한 검증**: 리소스 소유권 또는 role 확인
- [ ] **입력 검증**: 모든 사용자 입력 유효성 검사
- [ ] **SQL Injection**: Supabase 클라이언트 사용 (자동 방지)
- [ ] **XSS 방지**: React 자동 이스케이프 신뢰, dangerouslySetInnerHTML 금지
- [ ] **민감 정보**: 클라이언트에 비밀번호/토큰 노출 금지
- [ ] **환경 변수**: NEXT_PUBLIC_ 접두사 신중하게 사용

---

## 9. 에러 처리 패턴

### 에러 처리 원칙:
- **명시적 에러 처리**: 모든 비동기 작업에 try-catch
- **구체적인 에러 메시지**: 사용자가 이해할 수 있는 메시지
- **에러 로깅**: 서버 에러는 console.error로 기록
- **Fallback UI**: 에러 발생 시 대안 UI 제공

### 예시:
```typescript
// API Route 에러 처리 템플릿
export async function POST(request: Request) {
  try {
    // 1. 인증 확인
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: { code: 'UNAUTHORIZED', message: '로그인이 필요합니다' } },
        { status: 401 }
      );
    }
    
    // 2. 입력 유효성 검사
    const body = await request.json();
    if (!body.title || body.title.trim().length === 0) {
      return NextResponse.json(
        { success: false, error: { code: 'VALIDATION_ERROR', message: '제목을 입력해주세요' } },
        { status: 400 }
      );
    }
    
    // 3. 비즈니스 로직 실행
    const { data, error } = await supabase.from('posts').insert({
      title: body.title,
      content: body.content,
      user_id: user.id,
    }).select().single();
    
    if (error) throw error;
    
    return NextResponse.json({ success: true, data }, { status: 201 });
    
  } catch (error) {
    console.error('Post creation error:', error);
    return NextResponse.json(
      { success: false, error: { code: 'SERVER_ERROR', message: '게시글 작성에 실패했습니다' } },
      { status: 500 }
    );
  }
}
```

---

## 10. 코드 분리 및 리팩토링 기준

### 컴포넌트 크기 제한 ⚠️ 필수

| 대상 | 최대 줄 수 | 초과 시 조치 |
|-----|-----------|-------------|
| 페이지 컴포넌트 | 200줄 | 하위 컴포넌트로 분리 |
| 일반 컴포넌트 | 150줄 | 작은 컴포넌트로 분리 |
| 커스텀 훅 | 100줄 | 작은 훅으로 분리 |
| 함수 | 50줄 | 헬퍼 함수로 분리 |
| useState 개수 | 5개 | 커스텀 훅으로 추출 |

### 컴포넌트 분리 원칙

**1. 페이지 컴포넌트는 "조합"만 담당**
```typescript
// ✅ GOOD: 페이지는 컴포넌트를 조합만 함
export default function PostDetailPage() {
  const { post, isLoading, error } = usePost(postId);
  
  if (isLoading) return <PostSkeleton />;
  if (error) return <PostError error={error} />;
  
  return (
    <div className="max-w-4xl mx-auto">
      <PostHeader post={post} />
      <PostContent post={post} />
      <CommentSection postId={post.id} />
    </div>
  );
}

// ❌ BAD: 페이지에 모든 로직과 UI가 있음 (500줄 이상)
export default function PostDetailPage() {
  const [post, setPost] = useState(null);
  const [comments, setComments] = useState([]);
  const [isLiked, setIsLiked] = useState(false);
  // ... 10개 이상의 useState
  // ... 5개 이상의 useEffect
  // ... 수백 줄의 JSX
}
```

**2. 관련 상태는 커스텀 훅으로 추출**
```typescript
// ✅ GOOD: 관련 상태와 로직을 훅으로 분리
// hooks/usePost.ts
export function usePost(postId: string) {
  const [post, setPost] = useState<Post | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string>('');
  
  useEffect(() => {
    // 조회 로직
  }, [postId]);
  
  const refresh = async () => { /* 새로고침 */ };
  
  return { post, isLoading, error, refresh };
}

// hooks/useComments.ts
export function useComments(postId: string) {
  const [comments, setComments] = useState<Comment[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  
  const addComment = async (content: string) => { /* 추가 */ };
  const deleteComment = async (id: number) => { /* 삭제 */ };
  
  return { comments, isLoading, addComment, deleteComment };
}
```

**3. 반복되는 UI는 컴포넌트로 추출**
```typescript
// ❌ BAD: 같은 UI 패턴이 반복됨
{comments.map(comment => (
  <div className="...">
    <span>{comment.author}</span>
    <span>{formatDate(comment.created_at)}</span>
    <p>{comment.content}</p>
    {comment.replies?.map(reply => (
      <div className="..."> {/* 거의 동일한 구조 반복 */}
        <span>{reply.author}</span>
        <span>{formatDate(reply.created_at)}</span>
        <p>{reply.content}</p>
      </div>
    ))}
  </div>
))}

// ✅ GOOD: 재사용 가능한 컴포넌트로 분리
function CommentItem({ comment, depth = 0 }: { comment: Comment; depth?: number }) {
  return (
    <div className={cn("...", depth > 0 && "ml-8")}>
      <CommentHeader author={comment.author} date={comment.created_at} />
      <CommentContent content={comment.content} />
      {comment.replies?.map(reply => (
        <CommentItem key={reply.id} comment={reply} depth={depth + 1} />
      ))}
    </div>
  );
}
```

**4. 유틸리티 함수는 별도 파일로 분리**
```typescript
// ❌ BAD: 컴포넌트 내부에 유틸리티 함수
function PostPage() {
  const formatDate = (date: string) => { /* 30줄 */ };
  const parseContent = (content: string) => { /* 20줄 */ };
  // ...
}

// ✅ GOOD: lib/utils/ 에 분리
// lib/utils/date.ts
export function formatRelativeDate(date: string): string { /* ... */ }

// lib/utils/text.ts
export function parseContentWithMentions(content: string): ReactNode[] { /* ... */ }
```

### 분리 기준 체크리스트

- [ ] 페이지 컴포넌트가 200줄 초과 → 하위 컴포넌트 분리
- [ ] useState가 5개 초과 → 커스텀 훅 추출
- [ ] useEffect가 3개 초과 → 커스텀 훅 추출
- [ ] 같은 UI 패턴 2번 이상 반복 → 공통 컴포넌트 추출
- [ ] 유틸리티 함수가 컴포넌트 내부에 있음 → lib/utils/ 로 이동
- [ ] 이벤트 핸들러가 30줄 이상 → 함수 분리 또는 훅 추출

### 폴더 구조 규칙

```
src/
├── app/                          # 페이지 (조합만, 200줄 이하)
│   └── community/posts/[id]/
│       └── page.tsx
│
├── components/                   # UI 컴포넌트 (150줄 이하)
│   ├── community/
│   │   ├── post-detail/          # 복잡한 페이지는 폴더로 분리
│   │   │   ├── PostHeader.tsx
│   │   │   ├── PostContent.tsx
│   │   │   ├── CommentSection.tsx
│   │   │   └── CommentItem.tsx
│   │   └── CreatePostDialog.tsx
│   └── ui/                       # 공통 UI 컴포넌트
│
├── hooks/                        # 커스텀 훅 (100줄 이하)
│   ├── usePost.ts
│   ├── useComments.ts
│   └── useCurrentUser.ts
│
└── lib/utils/                    # 유틸리티 함수
    ├── date.ts
    └── text.ts
```

### 리팩토링이 필요한 신호:
- [ ] 같은 코드가 3곳 이상에서 반복됨 → 공통 함수/컴포넌트 추출
- [ ] 함수가 50줄 이상 → 작은 함수로 분리
- [ ] 컴포넌트가 200줄 이상 → 하위 컴포넌트로 분리
- [ ] props가 5개 이상 → 객체로 그룹화 또는 Context 고려
- [ ] any 타입 사용 → 구체적인 타입 정의
- [ ] 주석 없이는 이해 불가 → 코드 자체를 명확하게 수정

### 리팩토링 시 주의사항:
```typescript
// 1. 기존 동작 보존 확인
// 2. 단계적으로 진행 (한 번에 너무 많이 변경하지 않음)
// 3. 변경 전후 테스트

// ❌ BAD: 한 번에 대규모 변경
// ✅ GOOD: 작은 단위로 점진적 개선
```

---

## 11. 코드 작성 워크플로우

코드를 작성할 때 다음 순서를 따릅니다:

1. **설계 설명**: 문제 분석 및 해결 방안 설명
2. **아키텍처 검토**: 확장성, 유지보수성, 보안 고려
3. **타입 정의**: 인터페이스 및 타입 먼저 정의
4. **권한 설계**: 인증/인가 요구사항 정의
5. **에러 케이스 정의**: 예상되는 에러 상황 목록화
6. **구현**: 위 원칙들을 따르며 코드 작성
7. **보안 검토**: 체크리스트 확인
8. **성능 검토**: 불필요한 리렌더링, N+1 쿼리 확인

---

## 12. 유지보수성 설계

### 원칙:
- **단일 책임 원칙**: 각 함수/클래스는 하나의 책임만 가짐
- **DRY (Don't Repeat Yourself)**: 중복 코드 제거
- **명확한 네이밍**: 변수/함수명만으로도 의도가 명확해야 함
- **모듈화**: 재사용 가능한 작은 단위로 분리
- **타입 안정성**: TypeScript 타입을 명확히 정의

### 네이밍 규칙:
```typescript
// 컴포넌트: PascalCase
function PostCard() {}

// 함수: camelCase, 동사로 시작
function fetchPosts() {}
function handleSubmit() {}
function validateInput() {}

// 상수: SCREAMING_SNAKE_CASE
const MAX_POST_LENGTH = 10000;
const API_BASE_URL = '/api';

// 타입/인터페이스: PascalCase
interface PostData {}
type UserRole = 'admin' | 'user';

// boolean 변수: is/has/can 접두사
const isLoading = true;
const hasPermission = false;
const canEdit = true;
```

---

## 13. 파일 구조 및 Import 규칙

### Import 순서:
```typescript
// 1. React/Next.js 내장
import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

// 2. 외부 라이브러리
import { format } from 'date-fns';
import { toast } from 'sonner';

// 3. 내부 컴포넌트/유틸
import { Button } from '@/components/ui/button';
import { createClient } from '@/lib/supabase/client';

// 4. 타입
import type { Post, User } from '@/types';

// 5. 스타일 (있는 경우)
import styles from './Component.module.css';
```

### 컴포넌트 파일 구조:
```typescript
// 1. Import
// 2. 타입 정의
// 3. 상수
// 4. 헬퍼 함수 (컴포넌트 외부)
// 5. 컴포넌트
// 6. Export
```

---

## 14. 예외 상황

다음과 같은 경우에도 위 원칙을 준수합니다:
- 프로토타입 코드
- 테스트 코드  
- 임시 코드 (나중에 리팩토링 예정이어도)

단, 긴급 핫픽스의 경우 최소한의 원칙만 적용하고 TODO 주석으로 기술 부채 표시:
```typescript
// TODO(@username): 임시 처리, 정상적인 에러 핸들링 필요 - 2026-02-15
```
