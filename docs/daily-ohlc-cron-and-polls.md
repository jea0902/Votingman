# 매일 시가·종가 자동 기록 및 sentiment_polls 정리

> **기능 명세**: BTC/USDT 시장이 위 방식으로 정상 작동한 뒤, **한국(코스피·코스닥)** 및 **미국(S&P500·나스닥)** 지수 시장도 **동일한 방식**(매일 시가·종가 자동 조회·DB 기록)으로 확장할 것. 실천 항목으로 명세에 반영하고 단계적으로 구현한다.

## 1. 당일 시가 00:01 / 당일 종가 다음날 00:01 자동 기록 — 가능 여부와 방법

### 가능 여부: **가능합니다.**

- **당일 시가**: 그날 KST 00:00 시점 가격 → **그날 00:01 KST**가 되면 이미 확정되므로, 00:01에 조회·기록 가능.
- **당일 종가**: 다음날 KST 00:00 시점 가격 = “당일 봉의 종가” → **다음날 00:01 KST**가 되면 확정되므로, 다음날 00:01에 조회·기록 가능.

### 구체적 방법

**한 번의 스케줄로 두 가지 모두 처리하는 방식 (권장)**

- **실행 시점**: 매일 **KST 00:01**에 한 번만 실행.
- **그 시점에 할 일**:
  1. **“어제”(yesterday) 폴**: 어제 날짜의 `btc_close`(= 오늘 00:00 KST 가격)를 API로 조회해 DB에 기록.  
     (이미 “어제” 폴 행의 `btc_open`은 전날 00:01에 기록되어 있음.)
  2. **“오늘”(today) 폴**: 오늘 날짜의 `btc_open`(= 오늘 00:00 KST 가격)을 API로 조회해 DB에 기록.  
     `btc_close`는 내일 00:01에 기록.

즉, **매일 00:01 KST 한 번**이면  
- **당일 시가** = 오늘 폴의 `btc_open` 기록  
- **전날 종가** = 어제 폴의 `btc_close` 기록  
을 동시에 처리할 수 있습니다.

**구현 수단 (택 1)**

| 수단 | 설명 |
|------|------|
| **Vercel Cron** | `vercel.json`에 cron 표현식으로 `15 0 * * *` (UTC 00:15 ≈ KST 09:15) 또는 **KST 00:01에 맞춘 UTC** (전날 15:01 UTC) `1 15 * * *` 설정. 해당 시각에 `GET /api/cron/btc-ohlc-daily` 같은 전용 API를 호출하도록 설정. |
| **외부 Cron 서비스** | cron-job.org, GitHub Actions 등에서 매일 KST 00:01에 위 API URL을 호출. 호출 시 `Authorization: Bearer <CRON_SECRET>` 등으로 인증. |
| **서버/VM cron** | 호스트에서 `crontab` 등으로 매일 00:01 KST에 `curl`로 동일 API 호출. |

**인증**: API는 `Authorization: Bearer <CRON_SECRET>` 또는 `x-cron-secret: <CRON_SECRET>` 헤더를 검사합니다. 환경 변수 `CRON_SECRET`을 설정한 뒤, Vercel Cron은 기본적으로 헤더를 붙이지 않으므로 **외부 스케줄러**(cron-job.org 등)에서 위 헤더를 넣어 호출하는 방식을 권장합니다. (Vercel에 CRON_SECRET을 넣고 외부 서비스에서 동일 값을 헤더에 넣으면 됩니다.)

API 내부 로직 요약:

1. KST 기준 “오늘” / “어제” 날짜 계산.
2. **어제 (poll_date = yesterday, market = btc)**  
   - 해당 `sentiment_polls` 행이 없으면 생성(투표 0명이어도 생성).  
   - Binance 등 API로 어제 봉 시가·종가 조회 후 `btc_open`, `btc_close` 갱신.
3. **오늘 (poll_date = today, market = btc)**  
   - 해당 행이 없으면 생성.  
   - API로 오늘 00:00 시가 조회 후 `btc_open` 갱신, `btc_close`는 null 유지(내일 00:01에 채움).

---

## 2. 결과를 DB에 날짜별로 정리할 수 있는지

**가능합니다.** 이미 그렇게 설계되어 있습니다.

- **테이블**: `sentiment_polls`
- **날짜·시장 구분**: `(poll_date, market)` 당 1행 (UNIQUE).
- **저장 내용**: `poll_date`, `market`, `btc_open`, `btc_close`, `btc_change_pct`, 롱/숏 집계 등.

따라서 매일 00:01 자동 프로세스가 위처럼 “오늘/어제” 행을 생성·갱신하면, **날짜별로** 시가·종가가 정리된 상태로 쌓입니다.  
조회 시 `WHERE poll_date = ? AND market = ?` 또는 `ORDER BY poll_date DESC` 등으로 날짜별 조회·관리 가능합니다.

---

## 3. 대상 시장: BTC 우선, 이후 한국·미국 지수 동일 방식

- **현재 구현 대상**: **BTC/USDT** (비트코인)만 매일 시가·종가 자동 기록.
- **기능 명세·실천 방향**:
  - **한국**: 코스피(KOSPI), 코스닥(KOSDAQ) 지수  
  - **미국**: S&P 500, 나스닥(NASDAQ) 지수  
  → BTC 시장이 정상 동작한 뒤, **동일한 방식**(매일 시가·종가 자동 조회·DB 기록)으로 확장할 것.
- 각 시장별로 “시가/종가 정의”(거래소/지수 기준, KST 00:00 등)와 “데이터 소스 API”만 명세에 추가하면, 같은 크론 + 같은 테이블 구조(`poll_date`, `market`, 해당 시장용 open/close 컬럼 또는 공통 컬럼)로 확장 가능합니다.

---

## 4. 자동 프로세스에서 “투표자 유무와 관계없이” 폴 행 생성 가능 여부

**가능합니다.**

- 자동 프로세스는 **투표 여부를 보지 않고**,  
  “해당 (poll_date, market)에 대한 행이 있는지”만 보고 **없으면 INSERT, 있으면 UPDATE** 하면 됩니다.
- 따라서 **그날 투표자가 0명이어도** `sentiment_polls`에는 해당 날짜·시장 행이 생기고, 시가·종가만 채워집니다.
- 투표가 나중에 들어오면 `sentiment_votes`와 폴의 `long_count`/`short_count`, `long_coin_total`/`short_coin_total`만 갱신하면 됩니다.

---

## 5. sentiment_polls 테이블의 의미와 존재 의의

### 의미

- **이름**: “일별 투표 마스터” (또는 “일별·시장별 투표 마스터”).
- **한 행이 나타내는 것**: **“(poll_date) 날짜, (market) 시장에 대한 한 번의 가격 예측 투표”** 단위.
  - 예: `poll_date = 2025-02-06`, `market = btc` → “2025-02-06 비트코인 가격을 예측하는 투표” 하나.

### 존재 의의

| 목적 | 설명 |
|------|------|
| **투표의 단위 정의** | “어느 날, 어느 시장”을 예측하는지 식별. `sentiment_votes`는 반드시 어떤 `poll_id`(즉, 어떤 sentiment_polls 행)에 속함. |
| **판정·정산의 근거** | 해당일의 **시가·종가**를 저장 → 롱/숏 당첨 여부와 정산이 이 값에 의해 결정됨. 투표 유무와 관계없이 “그날 가격”이 있어야 신뢰 가능. |
| **집계 캐시** | `long_count`, `short_count`, `long_coin_total`, `short_coin_total` 등으로 UI/정산에서 매번 votes를 집계하지 않아도 됨. |

정리하면, **sentiment_polls**는  
“그날 그 시장에 대한 **질문(투표 주제)** + **정답(시가·종가)** + **참여 집계**”를 한 행에 담는 테이블이고,  
**투표자가 없어도 “질문과 정답”은 매일 자동으로 채워져야 시스템 신뢰성이 유지됩니다.**  
그래서 자동 프로세스가 **투표 유무와 무관하게** 매일 해당 (poll_date, market) 행을 생성·갱신하는 것이 설계와 맞습니다.
